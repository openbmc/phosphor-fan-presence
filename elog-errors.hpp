// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <string>
#include <tuple>
#include <type_traits>
#include <sdbusplus/exception.hpp>
#include <phosphor-logging/log.hpp>
#include <phosphor-logging/elog.hpp>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace Error
{
    struct MapperCallFailure;
} // namespace Error
} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace Error
{
    struct TimerFailure;
} // namespace Error
} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace Error
{
    struct InternalFailure;
} // namespace Error
} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus


namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace _TimerFailure
{

struct RETURN_CODE
{
    static constexpr auto str = "RETURN_CODE=%d";
    static constexpr auto str_short = "RETURN_CODE";
    using type = std::tuple<std::decay_t<decltype(str)>,int32_t>;
    explicit constexpr RETURN_CODE(int32_t a) : _entry(entry(str, a)) {};
    type _entry;
};
struct MESSAGE
{
    static constexpr auto str = "MESSAGE=%s";
    static constexpr auto str_short = "MESSAGE";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr MESSAGE(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _TimerFailure

struct TimerFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Common.Fan.TimerFailure";
    static constexpr auto errDesc = "Fan sd_event Timer Failed";
    static constexpr auto L = level::ERR;
    using RETURN_CODE = _TimerFailure::RETURN_CODE;
    using MESSAGE = _TimerFailure::MESSAGE;
    using metadata_types = std::tuple<RETURN_CODE, MESSAGE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Fan::Error::TimerFailure>
{
    using type = xyz::openbmc_project::Common::Fan::TimerFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace _MapperCallFailure
{

struct MESSAGE
{
    static constexpr auto str = "MESSAGE=%s";
    static constexpr auto str_short = "MESSAGE";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr MESSAGE(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _MapperCallFailure

struct MapperCallFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Common.Fan.MapperCallFailure";
    static constexpr auto errDesc = "Fan Mapper Call Failed";
    static constexpr auto L = level::ERR;
    using MESSAGE = _MapperCallFailure::MESSAGE;
    using metadata_types = std::tuple<MESSAGE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Fan::Error::MapperCallFailure>
{
    using type = xyz::openbmc_project::Common::Fan::MapperCallFailure;
};

}

namespace xyz
{
namespace openbmc_project
{
namespace Common
{
namespace Fan
{
namespace _InternalFailure
{

struct MESSAGE
{
    static constexpr auto str = "MESSAGE=%s";
    static constexpr auto str_short = "MESSAGE";
    using type = std::tuple<std::decay_t<decltype(str)>,const char*>;
    explicit constexpr MESSAGE(const char* a) : _entry(entry(str, a)) {};
    type _entry;
};

}  // namespace _InternalFailure

struct InternalFailure : public sdbusplus::exception_t
{
    static constexpr auto errName = "xyz.openbmc_project.Common.Fan.InternalFailure";
    static constexpr auto errDesc = "Internal Fan Control Failed";
    static constexpr auto L = level::ERR;
    using MESSAGE = _InternalFailure::MESSAGE;
    using metadata_types = std::tuple<MESSAGE>;

    const char* name() const noexcept
    {
        return errName;
    }

    const char* description() const noexcept
    {
        return errDesc;
    }

    const char* what() const noexcept
    {
        return errName;
    }
};

} // namespace Fan
} // namespace Common
} // namespace openbmc_project
} // namespace xyz


namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Common::Fan::Error::InternalFailure>
{
    using type = xyz::openbmc_project::Common::Fan::InternalFailure;
};

}


} // namespace logging

} // namespace phosphor
